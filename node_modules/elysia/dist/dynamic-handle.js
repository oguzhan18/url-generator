import{mapEarlyResponse as e,mapResponse as t}from"./handler";import{NotFoundError as r,ValidationError as a}from"./error";import{parse as s}from"fast-querystring";import{signCookie as o}from"./utils";import{parseCookie as i}from"./cookie";export const createDynamicHandler=n=>async l=>{let f;let c={cookie:{},status:200,headers:{}};n.decorators?((f=n.decorators).request=l,f.set=c,f.store=n.store):f={set:c,store:n.store,request:l};let d=l.url,u=d.indexOf("/",11),h=d.indexOf("?",u+1),m=-1===h?d.substring(u):d.substring(u,h);try{let u;for(let t=0;t<n.event.request.length;t++){let r=(0,n.event.request[t])(f);if(r instanceof Promise&&(r=await r),r=e(r,c))return r}let p=n.dynamicRouter.find(l.method,m)??n.dynamicRouter.find("ALL",m);if(!p)throw new r;let{handle:w,hooks:g,validator:k,content:y}=p.store;if("GET"!==l.method&&"HEAD"!==l.method){if(y)switch(y){case"application/json":u=await l.json();break;case"text/plain":u=await l.text();break;case"application/x-www-form-urlencoded":u=s(await l.text());break;case"application/octet-stream":u=await l.arrayBuffer();break;case"multipart/form-data":u={};let e=await l.formData();for(let t of e.keys()){if(u[t])continue;let r=e.getAll(t);1===r.length?u[t]=r[0]:u[t]=r}}else{let e=l.headers.get("content-type");if(e){let t=e.indexOf(";");-1!==t&&(e=e.slice(0,t));for(let t=0;t<n.event.parse.length;t++){let r=n.event.parse[t](f,e);if(r instanceof Promise&&(r=await r),r){u=r;break}}if(void 0===u)switch(e){case"application/json":u=await l.json();break;case"text/plain":u=await l.text();break;case"application/x-www-form-urlencoded":u=s(await l.text());break;case"application/octet-stream":u=await l.arrayBuffer();break;case"multipart/form-data":u={};let r=await l.formData();for(let e of r.keys()){if(u[e])continue;let t=r.getAll(e);1===t.length?u[e]=t[0]:u[e]=t}}}}}for(let[e,t]of(f.body=u,f.params=p?.params||void 0,f.query=-1===h?{}:s(d.substring(h+1)),f.headers={},l.headers.entries()))f.headers[e]=t;let v=k?.cookie?.schema;f.cookie=await i(f.set,f.headers.cookie,v?{secret:void 0!==v.secrets?"string"==typeof v.secrets?v.secrets:v.secrets.join(","):void 0,sign:!0===v.sign||(void 0!==v.sign?"string"==typeof v.sign?v.sign:v.sign.join(","):void 0)}:void 0);for(let e=0;e<g.transform.length;e++){let t=g.transform[e](f);"derive"===g.transform[e].$elysia?t instanceof Promise?Object.assign(f,await t):Object.assign(f,t):t instanceof Promise&&await t}if(k){if(k.headers){let e={};for(let t in l.headers)e[t]=l.headers.get(t);if(!1===k.headers.Check(e))throw new a("header",k.headers,e)}if(k.params?.Check(f.params)===!1)throw new a("params",k.params,f.params);if(k.query?.Check(f.query)===!1)throw new a("query",k.query,f.query);if(k.cookie){let e={};for(let[t,r]of Object.entries(f.cookie))e[t]=r.value;if(k.cookie?.Check(e)===!1)throw new a("cookie",k.cookie,e)}if(k.body?.Check(u)===!1)throw new a("body",k.body,u)}for(let t=0;t<g.beforeHandle.length;t++){let r=g.beforeHandle[t](f);if(r instanceof Promise&&(r=await r),void 0!==r){f.response=r;for(let e=0;e<g.afterHandle.length;e++){let t=g.afterHandle[e](f);t instanceof Promise&&(t=await t),t&&(r=t)}let t=e(r,f.set);if(t)return t}}let b=w(f);if(b instanceof Promise&&(b=await b),g.afterHandle.length){f.response=b;for(let t=0;t<g.afterHandle.length;t++){let r=g.afterHandle[t](f);r instanceof Promise&&(r=await r);let s=e(r,f.set);if(void 0!==s){let e=k?.response?.[b.status];if(e?.Check(s)===!1)throw new a("response",e,s);return s}}}else{let e=k?.response?.[b.status];if(e?.Check(b)===!1)throw new a("response",e,b)}if(f.set.cookie&&v?.sign){let e=v.secrets?"string"==typeof v.secrets?v.secrets:v.secrets[0]:void 0;if(!0===v.sign)for(let[e,t]of Object.entries(f.set.cookie))f.set.cookie[e].value=await o(t.value,"${secret}");else for(let t of v.sign)t in v.properties&&f.set.cookie[t]?.value&&(f.set.cookie[t].value=await o(f.set.cookie[t].value,e))}return t(b,f.set)}catch(e){return e.status&&(c.status=e.status),n.handleError(f,e)}finally{for(let e of n.event.onResponse)await e(f)}};export const createDynamicErrorHandler=e=>async(r,a)=>{let s=Object.assign(r,{error:a,code:a.code});s.set=r.set;for(let a=0;a<e.event.error.length;a++){let o=e.event.error[a](s);if(o instanceof Promise&&(o=await o),null!=o)return t(o,r.set)}return new Response("string"==typeof a.cause?a.cause:a.message,{headers:r.set.headers,status:a.status??500})};