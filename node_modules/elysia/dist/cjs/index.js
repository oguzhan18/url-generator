"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvalidCookieSignature = exports.InternalServerError = exports.ValidationError = exports.NotFoundError = exports.ParseError = exports.error = exports.getResponseSchemaValidator = exports.mergeObjectArray = exports.mergeHook = exports.mergeDeep = exports.getSchemaValidator = exports.Cookie = exports.t = exports.mapEarlyResponse = exports.mapCompactResponse = exports.mapResponse = exports.Elysia = void 0;
const memoirist_1 = require("memoirist");
const eventemitter3_1 = __importDefault(require("eventemitter3"));
const trace_1 = require("./trace");
const ws_1 = require("./ws");
const handler_1 = require("./handler");
const compose_1 = require("./compose");
const utils_1 = require("./utils");
const dynamic_handle_1 = require("./dynamic-handle");
const error_1 = require("./error");
const type_system_1 = require("./type-system");
/**
 * ### Elysia Server
 * Main instance to create web server using Elysia
 *
 * ---
 * @example
 * ```typescript
 * import { Elysia } from 'elysia'
 *
 * new Elysia()
 *     .get("/", () => "Hello")
 *     .listen(8080)
 * ```
 */
class Elysia {
    getServer() {
        return this.server;
    }
    constructor(config) {
        this.dependencies = {};
        this.store = {};
        this.decorators = {};
        this.definitions = {
            type: {},
            error: {}
        };
        this.schema = {};
        this.macros = [];
        this.event = {
            start: [],
            request: [],
            parse: [],
            transform: [],
            beforeHandle: [],
            afterHandle: [],
            mapResponse: [],
            onResponse: [],
            trace: [],
            error: [],
            stop: []
        };
        this.reporter = new eventemitter3_1.default();
        this.server = null;
        this.validator = null;
        this.router = new memoirist_1.Memoirist();
        this.wsRouter = new memoirist_1.Memoirist();
        this.routes = [];
        this.staticRouter = {
            handlers: [],
            variables: '',
            map: {},
            all: ''
        };
        this.wsPaths = {};
        this.dynamicRouter = new memoirist_1.Memoirist();
        this.lazyLoadModules = [];
        this.path = '';
        this.stack = undefined;
        this.handle = async (request) => this.fetch(request);
        /**
         * Use handle can be either sync or async to save performance.
         *
         * Beside benchmark purpose, please use 'handle' instead.
         */
        this.fetch = (request) => {
            if (process.env.NODE_ENV === 'production')
                console.warn("Performance degradation found. Please call Elysia.compile() before using 'fetch'");
            return (this.fetch = this.config.aot
                ? (0, compose_1.composeGeneralHandler)(this)
                : (0, dynamic_handle_1.createDynamicHandler)(this))(request);
        };
        this.handleError = async (context, error) => (this.handleError = this.config.aot
            ? (0, compose_1.composeErrorHandler)(this)
            : (0, dynamic_handle_1.createDynamicErrorHandler)(this))(context, error);
        this.outerErrorHandler = (error) => new Response(error.message || error.name || 'Error', {
            // @ts-ignore
            status: error?.status ?? 500
        });
        /**
         * ### listen
         * Assign current instance to port and start serving
         *
         * ---
         * @example
         * ```typescript
         * new Elysia()
         *     .get("/", () => 'hi')
         *     .listen(8080)
         * ```
         */
        this.listen = (options, callback) => {
            if (!Bun)
                throw new Error('Bun to run');
            this.compile();
            if (typeof options === 'string') {
                options = +options.trim();
                if (Number.isNaN(options))
                    throw new Error('Port must be a numeric value');
            }
            const fetch = this.fetch;
            const serve = typeof options === 'object'
                ? {
                    development: !error_1.isProduction,
                    reusePort: true,
                    ...this.config.serve,
                    ...options,
                    websocket: {
                        ...this.config.websocket,
                        ...ws_1.websocket
                    },
                    fetch,
                    error: this.outerErrorHandler
                }
                : {
                    development: !error_1.isProduction,
                    reusePort: true,
                    ...this.config.serve,
                    websocket: {
                        ...this.config.websocket,
                        ...ws_1.websocket
                    },
                    port: options,
                    fetch,
                    error: this.outerErrorHandler
                };
            if (typeof Bun === 'undefined')
                throw new Error('.listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch');
            this.server = Bun?.serve(serve);
            if (this.event.start.length)
                for (let i = 0; i < this.event.start.length; i++)
                    this.event.start[i](this);
            if (callback)
                callback(this.server);
            process.on('beforeExit', () => {
                for (let i = 0; i < this.event.stop.length; i++)
                    this.event.stop[i](this);
            });
            Promise.all(this.lazyLoadModules).then(() => {
                Bun?.gc(false);
            });
            return this;
        };
        /**
         * ### stop
         * Stop server from serving
         *
         * ---
         * @example
         * ```typescript
         * const app = new Elysia()
         *     .get("/", () => 'hi')
         *     .listen(8080)
         *
         * // Sometime later
         * app.stop()
         * ```
         */
        this.stop = async () => {
            if (!this.server)
                throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
            this.server.stop();
            if (this.event.stop.length)
                for (let i = 0; i < this.event.stop.length; i++)
                    this.event.stop[i](this);
        };
        this.config = {
            forceErrorEncapsulation: true,
            prefix: '',
            aot: true,
            strictPath: false,
            scoped: false,
            cookie: {},
            analytic: false,
            ...config,
            seed: config?.seed === undefined ? '' : config?.seed
        };
        if (config?.analytic && (config?.name || config?.seed !== undefined))
            this.stack = new Error().stack;
    }
    add(method, paths, handle, localHook, { allowMeta = false, skipPrefix = false } = {
        allowMeta: false,
        skipPrefix: false
    }) {
        if (typeof paths === 'string')
            paths = [paths];
        for (let path of paths) {
            path =
                path === ''
                    ? path
                    : path.charCodeAt(0) === 47
                        ? path
                        : `/${path}`;
            if (this.config.prefix && !skipPrefix)
                path = this.config.prefix + path;
            if (localHook?.type)
                switch (localHook.type) {
                    case 'text':
                        localHook.type = 'text/plain';
                        break;
                    case 'json':
                        localHook.type = 'application/json';
                        break;
                    case 'formdata':
                        localHook.type = 'multipart/form-data';
                        break;
                    case 'urlencoded':
                        localHook.type = 'application/x-www-form-urlencoded';
                        break;
                    case 'arrayBuffer':
                        localHook.type = 'application/octet-stream';
                        break;
                    default:
                        break;
                }
            const models = this.definitions.type;
            let cookieValidator = (0, utils_1.getSchemaValidator)(localHook?.cookie ?? this.validator?.cookie, {
                dynamic: !this.config.aot,
                models,
                additionalProperties: true
            });
            if ((0, handler_1.isNotEmpty)(this.config.cookie ?? {})) {
                if (cookieValidator) {
                    // @ts-ignore
                    cookieValidator.schema = (0, utils_1.mergeCookie)(
                    // @ts-ignore
                    cookieValidator.schema, this.config.cookie ?? {});
                }
                else {
                    cookieValidator = (0, utils_1.getSchemaValidator)(
                    // @ts-ignore
                    type_system_1.t.Cookie({}, this.config.cookie), {
                        dynamic: !this.config.aot,
                        models,
                        additionalProperties: true
                    });
                }
            }
            const validator = {
                body: (0, utils_1.getSchemaValidator)(localHook?.body ?? this.validator?.body, {
                    dynamic: !this.config.aot,
                    models
                }),
                headers: (0, utils_1.getSchemaValidator)(localHook?.headers ?? this.validator?.headers, {
                    dynamic: !this.config.aot,
                    models,
                    additionalProperties: true
                }),
                params: (0, utils_1.getSchemaValidator)(localHook?.params ?? this.validator?.params, {
                    dynamic: !this.config.aot,
                    models
                }),
                query: (0, utils_1.getSchemaValidator)(localHook?.query ?? this.validator?.query, {
                    dynamic: !this.config.aot,
                    models
                }),
                cookie: cookieValidator,
                response: (0, utils_1.getResponseSchemaValidator)(localHook?.response ?? this.validator?.response, {
                    dynamic: !this.config.aot,
                    models
                })
            };
            const globalHook = this.event;
            const loosePath = path.endsWith('/')
                ? path.slice(0, path.length - 1)
                : path + '/';
            if (this.macros.length) {
                const createManager = (stackName) => (type, fn) => {
                    if (typeof type === 'function' || Array.isArray(type)) {
                        if (!localHook[stackName])
                            localHook[stackName] = [];
                        if (typeof localHook[stackName] === 'function')
                            localHook[stackName] = [localHook[stackName]];
                        if (Array.isArray(type))
                            localHook[stackName] = localHook[stackName].concat(type);
                        else
                            localHook[stackName].push(type);
                        return;
                    }
                    const { insert = 'after', stack = 'local' } = type;
                    if (stack === 'global') {
                        if (!Array.isArray(fn)) {
                            if (insert === 'before') {
                                ;
                                globalHook[stackName].unshift(fn);
                            }
                            else {
                                ;
                                globalHook[stackName].push(fn);
                            }
                        }
                        else {
                            if (insert === 'before') {
                                globalHook[stackName] = fn.concat(globalHook[stackName]);
                            }
                            else {
                                globalHook[stackName] = globalHook[stackName].concat(fn);
                            }
                        }
                        return;
                    }
                    else {
                        if (!localHook[stackName])
                            localHook[stackName] = [];
                        if (typeof localHook[stackName] === 'function')
                            localHook[stackName] = [localHook[stackName]];
                        if (!Array.isArray(fn)) {
                            if (insert === 'before') {
                                ;
                                localHook[stackName].unshift(fn);
                            }
                            else {
                                ;
                                localHook[stackName].push(fn);
                            }
                        }
                        else {
                            if (insert === 'before') {
                                localHook[stackName] = fn.concat(localHook[stackName]);
                            }
                            else {
                                localHook[stackName] =
                                    localHook[stackName].concat(fn);
                            }
                        }
                        return;
                    }
                };
                const manager = {
                    events: {
                        global: globalHook,
                        local: localHook
                    },
                    onParse: createManager('parse'),
                    onTransform: createManager('transform'),
                    onBeforeHandle: createManager('beforeHandle'),
                    onAfterHandle: createManager('afterHandle'),
                    onResponse: createManager('onResponse'),
                    onError: createManager('error')
                };
                for (const macro of this.macros) {
                    const customHookValues = {};
                    for (const [key, value] of Object.entries(localHook ?? {})) {
                        if (utils_1.primitiveHooks.includes(key))
                            continue;
                        customHookValues[key] = value;
                    }
                    // @ts-ignore
                    if (!macro.$elysiaChecksum)
                        // @ts-ignore
                        macro.$elysiaChecksum = [];
                    const hash = (0, utils_1.checksum)(JSON.stringify(customHookValues));
                    // @ts-ignore
                    if (macro.$elysiaChecksum.includes(hash))
                        continue;
                    // @ts-ignore
                    macro.$elysiaChecksum.push((0, utils_1.checksum)(JSON.stringify(customHookValues)));
                    (0, utils_1.traceBackMacro)(macro(manager), localHook);
                }
            }
            const hooks = (0, utils_1.mergeHook)(globalHook, localHook);
            const isFn = typeof handle === 'function';
            if (this.config.aot === false) {
                this.dynamicRouter.add(method, path, {
                    validator,
                    hooks,
                    content: localHook?.type,
                    handle
                });
                if (this.config.strictPath === false) {
                    this.dynamicRouter.add(method, loosePath, {
                        validator,
                        hooks,
                        content: localHook?.type,
                        handle
                    });
                }
                this.routes.push({
                    method,
                    path,
                    composed: null,
                    handler: handle,
                    hooks: hooks
                });
                return;
            }
            const mainHandler = (0, compose_1.composeHandler)({
                path,
                method,
                hooks,
                validator,
                handler: handle,
                handleError: this.handleError,
                onRequest: this.event.request,
                config: this.config,
                definitions: allowMeta ? this.definitions.type : undefined,
                schema: allowMeta ? this.schema : undefined,
                getReporter: () => this.reporter,
                setHeader: this.setHeaders
            });
            // @ts-ignore
            if (!isFn) {
                const context = Object.assign({
                    headers: {},
                    query: {},
                    params: {},
                    body: undefined,
                    request: new Request(`http://localhost${path}`),
                    store: this.store,
                    path: path,
                    set: {
                        headers: this.setHeaders ?? {},
                        status: 200
                    }
                }, this.decorators);
                let response;
                for (const onRequest of Object.values(hooks.request)) {
                    try {
                        const inner = (0, handler_1.mapEarlyResponse)(onRequest(context), context.set);
                        if (inner !== undefined) {
                            response = inner;
                            break;
                        }
                    }
                    catch (error) {
                        response = this.handleError(context, error);
                        break;
                    }
                }
                // @ts-ignore
                if (response)
                    mainHandler.response = response;
                else {
                    try {
                        // @ts-ignore
                        mainHandler.response = mainHandler(context);
                    }
                    catch (error) {
                        // @ts-ignore
                        mainHandler.response = this.handleError(context, error);
                    }
                }
            }
            const existingRouteIndex = this.routes.findIndex((route) => route.path === path && route.method === method);
            if (existingRouteIndex !== -1) {
                // remove route previously defined
                this.routes.splice(existingRouteIndex, 1);
            }
            this.routes.push({
                method,
                path,
                composed: mainHandler,
                handler: handle,
                hooks: hooks
            });
            if (method === '$INTERNALWS') {
                const loose = this.config.strictPath
                    ? undefined
                    : path.endsWith('/')
                        ? path.slice(0, path.length - 1)
                        : path + '/';
                if (path.indexOf(':') === -1 && path.indexOf('*') === -1) {
                    const index = this.staticRouter.handlers.length;
                    this.staticRouter.handlers.push(mainHandler);
                    // @ts-ignore
                    if (mainHandler.response instanceof Response)
                        this.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}].response\n`;
                    else
                        this.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}]\n`;
                    this.wsPaths[path] = index;
                    if (loose)
                        this.wsPaths[loose] = index;
                }
                else {
                    this.wsRouter.add('ws', path, mainHandler);
                    if (loose)
                        this.wsRouter.add('ws', loose, mainHandler);
                }
                return;
            }
            if (path.indexOf(':') === -1 && path.indexOf('*') === -1) {
                const index = this.staticRouter.handlers.length;
                this.staticRouter.handlers.push(mainHandler);
                // @ts-ignore
                if (mainHandler.response instanceof Response)
                    this.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}].response\n`;
                else
                    this.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}]\n`;
                if (!this.staticRouter.map[path])
                    this.staticRouter.map[path] = {
                        code: ''
                    };
                if (method === 'ALL')
                    this.staticRouter.map[path].all = `default: return st${index}(ctx)\n`;
                else {
                    // @ts-ignore
                    if (mainHandler.response instanceof Response)
                        this.staticRouter.map[path].code = `case '${method}': return st${index}.clone()\n${this.staticRouter.map[path].code}`;
                    else
                        this.staticRouter.map[path].code = `case '${method}': return st${index}(ctx)\n${this.staticRouter.map[path].code}`;
                }
                if (!this.config.strictPath) {
                    if (!this.staticRouter.map[loosePath])
                        this.staticRouter.map[loosePath] = {
                            code: ''
                        };
                    if (method === 'ALL')
                        this.staticRouter.map[loosePath].all = `default: return st${index}(ctx)\n`;
                    else {
                        // @ts-ignore
                        if (mainHandler.response instanceof Response)
                            this.staticRouter.map[loosePath].code = `case '${method}': return st${index}.clone()\n${this.staticRouter.map[loosePath].code}`;
                        else
                            this.staticRouter.map[loosePath].code = `case '${method}': return st${index}(ctx)\n${this.staticRouter.map[loosePath].code}`;
                    }
                }
            }
            else {
                this.router.add(method, path, mainHandler);
                if (!this.config.strictPath)
                    this.router.add(method, path.endsWith('/')
                        ? path.slice(0, path.length - 1)
                        : path + '/', mainHandler);
            }
        }
    }
    headers(header) {
        if (!header)
            return this;
        if (!this.setHeaders)
            this.setHeaders = {};
        this.setHeaders = (0, utils_1.mergeDeep)(this.setHeaders, header);
        return this;
    }
    /**
     * ### start | Life cycle event
     * Called after server is ready for serving
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onStart(({ url, port }) => {
     *         console.log("Running at ${url}:${port}")
     *     })
     *     .listen(8080)
     * ```
     */
    onStart(handler) {
        this.on('start', handler);
        return this;
    }
    /**
     * ### request | Life cycle event
     * Called on every new request is accepted
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onRequest(({ method, url }) => {
     *         saveToAnalytic({ method, url })
     *     })
     * ```
     */
    onRequest(handler) {
        this.on('request', handler);
        return this;
    }
    /**
     * ### parse | Life cycle event
     * Callback function to handle body parsing
     *
     * If truthy value is returned, will be assigned to `context.body`
     * Otherwise will skip the callback and look for the next one.
     *
     * Equivalent to Express's body parser
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onParse((request, contentType) => {
     *         if(contentType === "application/json")
     *             return request.json()
     *     })
     * ```
     */
    onParse(parser) {
        this.on('parse', parser);
        return this;
    }
    /**
     * ### transform | Life cycle event
     * Assign or transform anything related to context before validation.
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onTransform(({ params }) => {
     *         if(params.id)
     *             params.id = +params.id
     *     })
     * ```
     */
    onTransform(handler) {
        this.on('transform', handler);
        return this;
    }
    /**
     * ### After Handle | Life cycle event
     * Intercept request **after** main handler is called.
     *
     * If truthy value is returned, will be assigned as `Response`
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onAfterHandle((context, response) => {
     *         if(typeof response === "object")
     *             return JSON.stringify(response)
     *     })
     * ```
     */
    /**
     * Derive new property for each request with access to `Context`.
     *
     * If error is thrown, the scope will skip to handling error instead.
     *
     * ---
     * @example
     * new Elysia()
     *     .state('counter', 1)
     *     .derive(({ store }) => ({
     *         increase() {
     *             store.counter++
     *         }
     *     }))
     */
    resolve(resolver) {
        // @ts-ignore
        resolver.$elysia = 'resolve';
        return this.onBeforeHandle(resolver);
    }
    /**
     * ### Before Handle | Life cycle event
     * Intercept request **before(()) main handler is called.
     *
     * If truthy value is returned, will be assigned as `Response` and skip the main handler
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onBeforeHandle(({ params: { id }, status }) => {
     *         if(id && !isExisted(id)) {
     * 	           status(401)
     *
     *             return "Unauthorized"
     * 	       }
     *     })
     * ```
     */
    onBeforeHandle(handler) {
        this.on('beforeHandle', handler);
        return this;
    }
    /**
     * ### After Handle | Life cycle event
     * Intercept request **after** main handler is called.
     *
     * If truthy value is returned, will be assigned as `Response`
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onAfterHandle((context, response) => {
     *         if(typeof response === "object")
     *             return JSON.stringify(response)
     *     })
     * ```
     */
    onAfterHandle(handler) {
        this.on('afterHandle', handler);
        return this;
    }
    /**
     * ### After Handle | Life cycle event
     * Intercept request **after** main handler is called.
     *
     * If truthy value is returned, will be assigned as `Response`
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .mapResponse((context, response) => {
     *         if(typeof response === "object")
     *             return JSON.stringify(response)
     *     })
     * ```
     */
    mapResponse(handler) {
        this.on('mapResponse', handler);
        return this;
    }
    /**
     * ### response | Life cycle event
     * Called when handler is executed
     * Good for analytic metrics
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onError(({ code }) => {
     *         if(code === "NOT_FOUND")
     *             return "Path not found :("
     *     })
     * ```
     */
    onResponse(handler) {
        this.on('response', handler);
        return this;
    }
    /**
     * ### After Handle | Life cycle event
     * Intercept request **after** main handler is called.
     *
     * If truthy value is returned, will be assigned as `Response`
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onAfterHandle((context, response) => {
     *         if(typeof response === "object")
     *             return JSON.stringify(response)
     *     })
     * ```
     */
    trace(handler) {
        this.reporter.on('event', (0, trace_1.createTraceListener)(() => this.reporter, this.event.trace.length, handler));
        this.on('trace', handler);
        return this;
    }
    error(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    name, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    error) {
        switch (typeof name) {
            case 'string':
                // @ts-ignore
                error.prototype[error_1.ERROR_CODE] = name;
                // @ts-ignore
                this.definitions.error[name] = error;
                return this;
            case 'function':
                this.definitions.error = name(this.definitions.error);
                return this;
        }
        for (const [code, error] of Object.entries(name)) {
            // @ts-ignore
            error.prototype[error_1.ERROR_CODE] = code;
            // @ts-ignore
            this.definitions.error[code] = error;
        }
        return this;
    }
    /**
     * ### Error | Life cycle event
     * Called when error is thrown during processing request
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onError(({ code }) => {
     *         if(code === "NOT_FOUND")
     *             return "Path not found :("
     *     })
     * ```
     */
    onError(handler) {
        this.on('error', handler);
        return this;
    }
    /**
     * ### stop | Life cycle event
     * Called after server stop serving request
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onStop((app) => {
     *         cleanup()
     *     })
     * ```
     */
    onStop(handler) {
        this.on('stop', handler);
        return this;
    }
    /**
     * ### on
     * Syntax sugar for attaching life cycle event by name
     *
     * Does the exact same thing as `.on[Event]()`
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .on('error', ({ code }) => {
     *         if(code === "NOT_FOUND")
     *             return "Path not found :("
     *     })
     * ```
     */
    on(type, handlers) {
        for (let handler of Array.isArray(handlers) ? handlers : [handlers]) {
            handler = (0, utils_1.asGlobal)(handler);
            switch (type) {
                case 'start':
                    this.event.start.push(handler);
                    break;
                case 'request':
                    this.event.request.push(handler);
                    break;
                case 'parse':
                    this.event.parse.splice(this.event.parse.length - 1, 0, handler);
                    break;
                case 'transform':
                    this.event.transform.push(handler);
                    break;
                case 'beforeHandle':
                    this.event.beforeHandle.push(handler);
                    break;
                case 'afterHandle':
                    this.event.afterHandle.push(handler);
                    break;
                case 'mapResponse':
                    this.event.mapResponse.push(handler);
                    break;
                case 'response':
                    this.event.onResponse.push(handler);
                    break;
                case 'trace':
                    this.event.trace.push(handler);
                    break;
                case 'error':
                    this.event.error.push(handler);
                    break;
                case 'stop':
                    this.event.stop.push(handler);
                    break;
            }
        }
        return this;
    }
    /**
     * ### group
     * Encapsulate and group path with prefix
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .group('/v1', app => app
     *         .get('/', () => 'Hi')
     *         .get('/name', () => 'Elysia')
     *     })
     * ```
     */
    group(prefix, schemaOrRun, run) {
        const instance = new Elysia({
            ...this.config,
            prefix: ''
        });
        instance.store = this.store;
        instance.definitions = this.definitions;
        instance.getServer = () => this.server;
        const isSchema = typeof schemaOrRun === 'object';
        const sandbox = (isSchema ? run : schemaOrRun)(instance);
        this.decorators = (0, utils_1.mergeDeep)(this.decorators, instance.decorators);
        if (sandbox.event.request.length)
            this.event.request = [
                ...this.event.request,
                ...sandbox.event.request
            ];
        if (sandbox.event.onResponse.length)
            this.event.onResponse = [
                ...this.event.onResponse,
                ...sandbox.event.onResponse
            ];
        this.model(sandbox.definitions.type);
        Object.values(instance.routes).forEach(({ method, path, handler, hooks }) => {
            path = (isSchema ? '' : this.config.prefix) + prefix + path;
            if (isSchema) {
                const hook = schemaOrRun;
                const localHook = hooks;
                this.add(method, path, handler, (0, utils_1.mergeHook)(hook, {
                    ...localHook,
                    error: !localHook.error
                        ? sandbox.event.error
                        : Array.isArray(localHook.error)
                            ? [...localHook.error, ...sandbox.event.error]
                            : [localHook.error, ...sandbox.event.error]
                }));
            }
            else {
                this.add(method, path, handler, (0, utils_1.mergeHook)(hooks, {
                    error: sandbox.event.error
                }), {
                    skipPrefix: true
                });
            }
        });
        return this;
    }
    /**
     * ### guard
     * Encapsulate and pass hook into all child handler
     *
     * ---
     * @example
     * ```typescript
     * import { t } from 'elysia'
     *
     * new Elysia()
     *     .guard({
     *          schema: {
     *              body: t.Object({
     *                  username: t.String(),
     *                  password: t.String()
     *              })
     *          }
     *     }, app => app
     *         .get("/", () => 'Hi')
     *         .get("/name", () => 'Elysia')
     *     })
     * ```
     */
    guard(hook, run) {
        if (!run) {
            this.event = (0, utils_1.mergeLifeCycle)(this.event, hook);
            this.validator = {
                body: hook.body,
                headers: hook.headers,
                params: hook.params,
                query: hook.query,
                response: hook.response
            };
            return this;
        }
        const instance = new Elysia({
            ...this.config,
            prefix: ''
        });
        instance.store = this.store;
        instance.definitions = this.definitions;
        const sandbox = run(instance);
        this.decorators = (0, utils_1.mergeDeep)(this.decorators, instance.decorators);
        if (sandbox.event.request.length)
            this.event.request = [
                ...this.event.request,
                ...sandbox.event.request
            ];
        if (sandbox.event.onResponse.length)
            this.event.onResponse = [
                ...this.event.onResponse,
                ...sandbox.event.onResponse
            ];
        this.model(sandbox.definitions.type);
        Object.values(instance.routes).forEach(({ method, path, handler, hooks: localHook }) => {
            this.add(method, path, handler, (0, utils_1.mergeHook)(hook, {
                ...localHook,
                error: !localHook.error
                    ? sandbox.event.error
                    : Array.isArray(localHook.error)
                        ? [...localHook.error, ...sandbox.event.error]
                        : [localHook.error, ...sandbox.event.error]
            }));
        });
        return this;
    }
    /**
     * ### use
     * Merge separate logic of Elysia with current
     *
     * ---
     * @example
     * ```typescript
     * const plugin = (app: Elysia) => app
     *     .get('/plugin', () => 'hi')
     *
     * new Elysia()
     *     .use(plugin)
     * ```
     */
    use(plugin) {
        if (plugin instanceof Promise) {
            this.lazyLoadModules.push(plugin
                .then((plugin) => {
                if (typeof plugin === 'function') {
                    return plugin(this);
                }
                if (typeof plugin.default === 'function')
                    return plugin.default(this);
                // @ts-ignore
                return this._use(plugin);
            })
                .then((x) => x.compile()));
            return this;
        }
        else
            return this._use(plugin);
        return this;
    }
    _use(plugin) {
        if (typeof plugin === 'function') {
            const instance = plugin(this);
            if (instance instanceof Promise) {
                this.lazyLoadModules.push(instance
                    .then((plugin) => {
                    if (plugin instanceof Elysia) {
                        this.compile();
                        // Recompile async plugin routes
                        for (const { method, path, handler, hooks } of Object.values(plugin.routes)) {
                            this.add(method, path, handler, (0, utils_1.mergeHook)(hooks, {
                                error: plugin.event.error
                            }));
                        }
                        return plugin;
                    }
                    if (typeof plugin === 'function')
                        return plugin(this);
                    if (typeof plugin.default === 'function')
                        return plugin.default(this);
                    // @ts-ignore
                    return this._use(plugin);
                })
                    .then((x) => x.compile()));
                return this;
            }
            return instance;
        }
        const { name, seed } = plugin.config;
        plugin.getServer = () => this.getServer();
        this.headers(plugin.setHeaders);
        const isScoped = plugin.config.scoped;
        if (isScoped) {
            if (name) {
                if (!(name in this.dependencies))
                    this.dependencies[name] = [];
                const current = seed !== undefined
                    ? (0, utils_1.checksum)(name + JSON.stringify(seed))
                    : 0;
                if (this.dependencies[name].some(({ checksum }) => current === checksum))
                    return this;
                this.dependencies[name].push(!this.config?.analytic
                    ? {
                        name: plugin.config.name,
                        seed: plugin.config.seed,
                        checksum: current,
                        dependencies: plugin.dependencies
                    }
                    : {
                        name: plugin.config.name,
                        seed: plugin.config.seed,
                        checksum: current,
                        dependencies: plugin.dependencies,
                        stack: plugin.stack,
                        routes: plugin.routes,
                        decorators: plugin.decorators,
                        store: plugin.store,
                        type: plugin.definitions.type,
                        error: plugin.definitions.error,
                        derive: plugin.event.transform
                            // @ts-expect-error
                            .filter((x) => x.$elysia === 'derive')
                            .map((x) => ({
                            fn: x.toString(),
                            stack: new Error().stack ?? ''
                        })),
                        resolve: plugin.event.transform
                            // @ts-expect-error
                            .filter((x) => x.$elysia === 'derive')
                            .map((x) => ({
                            fn: x.toString(),
                            stack: new Error().stack ?? ''
                        }))
                    });
            }
            plugin.model(this.definitions.type);
            plugin.error(this.definitions.error);
            plugin.macros = [...this.macros, ...plugin.macros];
            plugin.onRequest((context) => {
                Object.assign(context, this.decorators);
                Object.assign(context.store, this.store);
            });
            plugin.event.trace = [...this.event.trace, ...plugin.event.trace];
            if (plugin.config.aot)
                plugin.compile();
            const instance = this.mount(plugin.fetch);
            this.routes = this.routes.concat(instance.routes);
            return this;
        }
        else {
            plugin.reporter = this.reporter;
            for (const trace of plugin.event.trace)
                this.trace(trace);
            if (name) {
                if (!(name in this.dependencies))
                    this.dependencies[name] = [];
                const current = seed !== undefined
                    ? (0, utils_1.checksum)(name + JSON.stringify(seed))
                    : 0;
                if (!this.dependencies[name].some(({ checksum }) => current === checksum))
                    this.macros.push(...plugin.macros);
            }
        }
        this.decorate(plugin.decorators);
        this.state(plugin.store);
        this.model(plugin.definitions.type);
        this.error(plugin.definitions.error);
        for (const { method, path, handler, hooks } of Object.values(plugin.routes)) {
            this.add(method, path, handler, (0, utils_1.mergeHook)(hooks, {
                error: plugin.event.error
            }));
        }
        if (!isScoped)
            if (name) {
                if (!(name in this.dependencies))
                    this.dependencies[name] = [];
                const current = seed !== undefined
                    ? (0, utils_1.checksum)(name + JSON.stringify(seed))
                    : 0;
                if (this.dependencies[name].some(({ checksum }) => current === checksum))
                    return this;
                this.dependencies[name].push(!this.config?.analytic
                    ? {
                        name: plugin.config.name,
                        seed: plugin.config.seed,
                        checksum: current,
                        dependencies: plugin.dependencies
                    }
                    : {
                        name: plugin.config.name,
                        seed: plugin.config.seed,
                        checksum: current,
                        dependencies: plugin.dependencies,
                        stack: plugin.stack,
                        routes: plugin.routes,
                        decorators: plugin.decorators,
                        store: plugin.store,
                        type: plugin.definitions.type,
                        error: plugin.definitions.error,
                        derive: plugin.event.transform
                            // @ts-expect-error
                            .filter((x) => x?.$elysia === 'derive')
                            .map((x) => ({
                            fn: x.toString(),
                            stack: new Error().stack ?? ''
                        })),
                        resolve: plugin.event.transform
                            // @ts-expect-error
                            .filter((x) => x?.$elysia === 'resolve')
                            .map((x) => ({
                            fn: x.toString(),
                            stack: new Error().stack ?? ''
                        }))
                    });
                this.event = (0, utils_1.mergeLifeCycle)(this.event, (0, utils_1.filterGlobalHook)(plugin.event), current);
            }
            else {
                this.event = (0, utils_1.mergeLifeCycle)(this.event, (0, utils_1.filterGlobalHook)(plugin.event));
            }
        return this;
    }
    macro(macro) {
        this.macros.push(macro);
        return this;
    }
    mount(path, handle) {
        if (path instanceof Elysia ||
            typeof path === 'function' ||
            path.length === 0 ||
            path === '/') {
            const run = typeof path === 'function'
                ? path
                : path instanceof Elysia
                    ? path.compile().fetch
                    : handle instanceof Elysia
                        ? handle.compile().fetch
                        : handle;
            const handler = async ({ request, path }) => run(new Request((0, utils_1.replaceUrlPath)(request.url, path || '/'), request));
            this.all('/', handler, {
                type: 'none'
            });
            this.all('/*', handler, {
                type: 'none'
            });
            return this;
        }
        const length = path.length;
        if (handle instanceof Elysia)
            handle = handle.compile().fetch;
        const handler = async ({ request, path }) => handle(new Request((0, utils_1.replaceUrlPath)(request.url, path.slice(length) || '/'), request));
        this.all(path, handler, {
            type: 'none'
        });
        this.all(path + (path.endsWith('/') ? '*' : '/*'), handler, {
            type: 'none'
        });
        return this;
    }
    /**
     * ### get
     * Register handler for path with method [GET]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .get('/', () => 'hi')
     *     .get('/with-hook', () => 'hi', {
     *         schema: {
     *             response: t.String()
     *         }
     *     })
     * ```
     */
    get(path, handler, hook) {
        this.add('GET', path, handler, hook);
        return this;
    }
    /**
     * ### post
     * Register handler for path with method [POST]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .post('/', () => 'hi')
     *     .post('/with-hook', () => 'hi', {
     *         schema: {
     *             response: t.String()
     *         }
     *     })
     * ```
     */
    post(path, handler, hook) {
        this.add('POST', path, handler, hook);
        return this;
    }
    /**
     * ### put
     * Register handler for path with method [PUT]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .put('/', () => 'hi')
     *     .put('/with-hook', () => 'hi', {
     *         schema: {
     *             response: t.String()
     *         }
     *     })
     * ```
     */
    put(path, handler, hook) {
        this.add('PUT', path, handler, hook);
        return this;
    }
    /**
     * ### patch
     * Register handler for path with method [PATCH]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .patch('/', () => 'hi')
     *     .patch('/with-hook', () => 'hi', {
     *         schema: {
     *             response: t.String()
     *         }
     *     })
     * ```
     */
    patch(path, handler, hook) {
        this.add('PATCH', path, handler, hook);
        return this;
    }
    /**
     * ### delete
     * Register handler for path with method [DELETE]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .delete('/', () => 'hi')
     *     .delete('/with-hook', () => 'hi', {
     *         schema: {
     *             response: t.String()
     *         }
     *     })
     * ```
     */
    delete(path, handler, hook) {
        this.add('DELETE', path, handler, hook);
        return this;
    }
    /**
     * ### options
     * Register handler for path with method [OPTIONS]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .options('/', () => 'hi')
     *     .options('/with-hook', () => 'hi', {
     *         schema: {
     *             response: t.String()
     *         }
     *     })
     * ```
     */
    options(path, handler, hook) {
        this.add('OPTIONS', path, handler, hook);
        return this;
    }
    /**
     * ### all
     * Register handler for path with any method
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .all('/', () => 'hi')
     * ```
     */
    all(path, handler, hook) {
        this.add('ALL', path, handler, hook);
        return this;
    }
    /**
     * ### head
     * Register handler for path with method [HEAD]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .head('/', () => 'hi')
     *     .head('/with-hook', () => 'hi', {
     *         schema: {
     *             response: t.String()
     *         }
     *     })
     * ```
     */
    head(path, handler, hook) {
        this.add('HEAD', path, handler, hook);
        return this;
    }
    /**
     * ### connect
     * Register handler for path with method [CONNECT]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .connect('/', () => 'hi')
     *     .connect('/with-hook', () => 'hi', {
     *         schema: {
     *             response: t.String()
     *         }
     *     })
     * ```
     */
    connect(path, handler, hook) {
        this.add('CONNECT', path, handler, hook);
        return this;
    }
    /**
     * ### ws
     * Register handler for path with method [ws]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .ws('/', {
     *         message(ws, message) {
     *             ws.send(message)
     *         }
     *     })
     * ```
     */
    ws(path, options) {
        const transform = options.transformMessage
            ? Array.isArray(options.transformMessage)
                ? options.transformMessage
                : [options.transformMessage]
            : undefined;
        let server = null;
        const validateMessage = (0, utils_1.getSchemaValidator)(options?.body, {
            models: this.definitions.type
        });
        const validateResponse = (0, utils_1.getSchemaValidator)(options?.response, {
            models: this.definitions.type
        });
        const parseMessage = (message) => {
            if (typeof message === 'string') {
                const start = message?.charCodeAt(0);
                if (start === 47 || start === 123)
                    try {
                        message = JSON.parse(message);
                    }
                    catch {
                        // Not empty
                    }
                else if ((0, utils_1.isNumericString)(message))
                    message = +message;
            }
            if (transform?.length)
                for (let i = 0; i < transform.length; i++) {
                    const temp = transform[i](message);
                    if (temp !== undefined)
                        message = temp;
                }
            return message;
        };
        this.route('$INTERNALWS', path, 
        // @ts-ignore
        (context) => {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            const { set, path, qi, headers, query, params } = context;
            if (server === null)
                server = this.getServer();
            if (server?.upgrade(context.request, {
                headers: typeof options.upgrade === 'function'
                    ? options.upgrade(context)
                    : options.upgrade,
                data: {
                    validator: validateResponse,
                    open(ws) {
                        options.open?.(new ws_1.ElysiaWS(ws, context));
                    },
                    message: (ws, msg) => {
                        const message = parseMessage(msg);
                        if (validateMessage?.Check(message) === false)
                            return void ws.send(new error_1.ValidationError('message', validateMessage, message).message);
                        options.message?.(new ws_1.ElysiaWS(ws, context), message);
                    },
                    drain(ws) {
                        options.drain?.(new ws_1.ElysiaWS(ws, context));
                    },
                    close(ws, code, reason) {
                        options.close?.(new ws_1.ElysiaWS(ws, context), code, reason);
                    }
                }
            }))
                return;
            set.status = 400;
            return 'Expected a websocket connection';
        }, {
            beforeHandle: options.beforeHandle,
            transform: options.transform,
            headers: options.headers,
            params: options.params,
            query: options.query
        });
        return this;
    }
    /**
     * ### route
     * Register handler for path with custom method
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .route('CUSTOM', '/', () => 'hi')
     *     .route('CUSTOM', '/with-hook', () => 'hi', {
     *         schema: {
     *             response: t.String()
     *         }
     *     })
     * ```
     */
    route(method, path, handler, { config, ...hook } = {
        config: {
            allowMeta: false
        }
    }) {
        this.add(method, path, handler, hook, config);
        return this;
    }
    /**
     * ### state
     * Assign global mutatable state accessible for all handler
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .state('counter', 0)
     *     .get('/', (({ counter }) => ++counter)
     * ```
     */
    state(name, value) {
        switch (typeof name) {
            case 'object':
                this.store = (0, utils_1.mergeDeep)(this.store, name);
                return this;
            case 'function':
                this.store = name(this.store);
                return this;
        }
        if (!(name in this.store)) {
            // eslint-disable-next-line no-extra-semi
            ;
            this.store[name] =
                value;
        }
        return this;
    }
    /**
     * ### decorate
     * Define custom method to `Context` accessible for all handler
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .decorate('getDate', () => Date.now())
     *     .get('/', (({ getDate }) => getDate())
     * ```
     */
    decorate(name, value) {
        switch (typeof name) {
            case 'object':
                this.decorators = (0, utils_1.mergeDeep)(this.decorators, name);
                return this;
            case 'function':
                this.decorators = name(this.decorators);
                return this;
        }
        // @ts-ignore
        if (!(name in this.decorators))
            this.decorators[name] = value;
        return this;
    }
    /**
     * Derive new property for each request with access to `Context`.
     *
     * If error is thrown, the scope will skip to handling error instead.
     *
     * ---
     * @example
     * new Elysia()
     *     .state('counter', 1)
     *     .derive(({ store }) => ({
     *         increase() {
     *             store.counter++
     *         }
     *     }))
     */
    derive(transform) {
        // @ts-ignore
        transform.$elysia = 'derive';
        return this.onTransform(transform);
    }
    model(name, model) {
        switch (typeof name) {
            case 'object':
                Object.entries(name).forEach(([key, value]) => {
                    if (!(key in this.definitions.type))
                        // @ts-ignore
                        this.definitions.type[key] = value;
                });
                return this;
            case 'function':
                this.definitions.type = name(this.definitions.type);
                return this;
        }
        ;
        this.definitions.type[name] = model;
        return this;
    }
    mapDerive(mapper) {
        // @ts-ignore
        mapper.$elysia = 'derive';
        return this.onTransform(mapper);
    }
    affix(base, type, word) {
        if (word === '')
            return this;
        const delimieter = ['_', '-', ' '];
        const capitalize = (word) => word[0].toUpperCase() + word.slice(1);
        const joinKey = base === 'prefix'
            ? (prefix, word) => delimieter.includes(prefix.at(-1) ?? '')
                ? prefix + word
                : prefix + capitalize(word)
            : delimieter.includes(word.at(-1) ?? '')
                ? (suffix, word) => word + suffix
                : (suffix, word) => word + capitalize(suffix);
        const remap = (type) => {
            const store = {};
            switch (type) {
                case 'decorator':
                    for (const key in this.decorators)
                        store[joinKey(word, key)] = this.decorators[key];
                    this.decorators = store;
                    break;
                case 'state':
                    for (const key in this.store)
                        store[joinKey(word, key)] = this.store[key];
                    this.store = store;
                    break;
                case 'model':
                    for (const key in this.definitions.type)
                        store[joinKey(word, key)] = this.definitions.type[key];
                    this.definitions.type = store;
                    break;
                case 'error':
                    for (const key in this.definitions.error)
                        store[joinKey(word, key)] = this.definitions.error[key];
                    this.definitions.error = store;
                    break;
            }
        };
        const types = Array.isArray(type) ? type : [type];
        for (const type of types.some((x) => x === 'all')
            ? ['decorator', 'state', 'model', 'error']
            : types)
            remap(type);
        return this;
    }
    prefix(type, word) {
        return this.affix('prefix', type, word);
    }
    suffix(type, word) {
        return this.affix('suffix', type, word);
    }
    compile() {
        this.fetch = this.config.aot
            ? (0, compose_1.composeGeneralHandler)(this)
            : (0, dynamic_handle_1.createDynamicHandler)(this);
        if (typeof this.server?.reload === 'function')
            this.server.reload({
                ...this.server,
                fetch: this.fetch
            });
        return this;
    }
    /**
     * Wait until all lazy loaded modules all load is fully
     */
    get modules() {
        return Promise.all(this.lazyLoadModules);
    }
}
exports.default = Elysia;
exports.Elysia = Elysia;
var handler_2 = require("./handler");
Object.defineProperty(exports, "mapResponse", { enumerable: true, get: function () { return handler_2.mapResponse; } });
Object.defineProperty(exports, "mapCompactResponse", { enumerable: true, get: function () { return handler_2.mapCompactResponse; } });
Object.defineProperty(exports, "mapEarlyResponse", { enumerable: true, get: function () { return handler_2.mapEarlyResponse; } });
var type_system_2 = require("./type-system");
Object.defineProperty(exports, "t", { enumerable: true, get: function () { return type_system_2.t; } });
var cookie_1 = require("./cookie");
Object.defineProperty(exports, "Cookie", { enumerable: true, get: function () { return cookie_1.Cookie; } });
var utils_2 = require("./utils");
Object.defineProperty(exports, "getSchemaValidator", { enumerable: true, get: function () { return utils_2.getSchemaValidator; } });
Object.defineProperty(exports, "mergeDeep", { enumerable: true, get: function () { return utils_2.mergeDeep; } });
Object.defineProperty(exports, "mergeHook", { enumerable: true, get: function () { return utils_2.mergeHook; } });
Object.defineProperty(exports, "mergeObjectArray", { enumerable: true, get: function () { return utils_2.mergeObjectArray; } });
Object.defineProperty(exports, "getResponseSchemaValidator", { enumerable: true, get: function () { return utils_2.getResponseSchemaValidator; } });
var error_2 = require("./error");
Object.defineProperty(exports, "error", { enumerable: true, get: function () { return error_2.error; } });
Object.defineProperty(exports, "ParseError", { enumerable: true, get: function () { return error_2.ParseError; } });
Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function () { return error_2.NotFoundError; } });
Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function () { return error_2.ValidationError; } });
Object.defineProperty(exports, "InternalServerError", { enumerable: true, get: function () { return error_2.InternalServerError; } });
Object.defineProperty(exports, "InvalidCookieSignature", { enumerable: true, get: function () { return error_2.InvalidCookieSignature; } });
//# sourceMappingURL=index.js.map